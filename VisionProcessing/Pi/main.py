#!/usr/bin/python
# -*- coding: utf-8 -*-
import threading
import enum
import cv2
import socket
import time
import numpy as np
from networktables import NetworkTables

# Only keep the threads running barring a halt
isOn = False

class Main:

    """
    Executive class for controlling flow
    """

    SOCK_IP = '10.2.63.5'  # Static IP for Driver's Station on FMS
    SOCK_PORT = '5810'  # TCIP Port to use for communication with Driver's Station
    NT_IP = 'roboRIO-263-FRC.local'  # RIO server IP for NetworkTables

    def __init__(self):
        """initializes all threads and class instances
        """
        self.image_retrieval = ImageRetriever()
        self.image_processor = FindTape()
        self.image_sender = Sender(SOCK_IP, SOCK_PORT, NT_IP)

        #Create continual threads to run
        self.procesor_t = threading.Thread(name='image_processor',
                target=self.image_processor.update,
                args=(self.image_retrieval, ))
        self.sender_t = threading.Thread(name='image_sender',
                target=self.image_sender.update_camerea_feed,
                args=(self.image_retrieval, ))

    def start():
        """responsible for starting threads that will continue until bot is in off state
        """
        self.processor_t.start()
        self.sender_t.start()


class FindTape:

    """
    An OpenCV pipeline generated by GRIP and modified by FIRST Team 263.
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        BlurType = Enum('BlurType',
                        'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter'
                        )
        self.__hsl_threshold_hue = [43.70503597122302,
                                    67.88395904436861]
        self.__hsl_threshold_saturation = [0.0, 65.70819112627989]
        self.__hsl_threshold_luminance = [197.21223021582733, 255.0]

        self.hsl_threshold_output = None

        self.__blur_input = self.hsl_threshold_output
        self.__blur_type = BlurType.Box_Blur
        self.__blur_radius = 1.8018018018018018

        self.blur_output = None

        self.__find_contours_input = self.blur_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

        self.__filter_contours_contours = self.find_contours_output
        self.__filter_contours_min_area = 1500.0
        self.__filter_contours_min_perimeter = 0.0
        self.__filter_contours_min_width = 2.5
        self.__filter_contours_max_width = 1000.0
        self.__filter_contours_min_height = 2.5
        self.__filter_contours_max_height = 1000.0
        self.__filter_contours_solidity = [94.42446043165468, 100]
        self.__filter_contours_max_vertices = 1000000.0
        self.__filter_contours_min_vertices = 0.0
        self.__filter_contours_min_ratio = 0.0
        self.__filter_contours_max_ratio = 1000.0

        self.filter_contours_output = None

    def update(self, retriever, nt_manager):
        """Continually updates both camera feeds' data through NetworkTables
        """
        global isOn
        while isOn:
            nt_manager.update_gear_coords(process(retriever.get_latest_gear()))
            nt_manager.update_shooter_coords(process(retriever.get_latest_shooter()))

    def process(self, source0):
        """
........Runs the pipeline and sets all outputs to new values.
........"""

        # Step HSL_Threshold0:

        self.__hsl_threshold_input = source0
        self.hsl_threshold_output = \
            self.__hsl_threshold(self.__hsl_threshold_input,
                                 self.__hsl_threshold_hue,
                                 self.__hsl_threshold_saturation,
                                 self.__hsl_threshold_luminance)

        # Step Blur0:

        self.__blur_input = self.hsl_threshold_output
        self.blur_output = self.__blur(self.__blur_input,
                self.__blur_type, self.__blur_radius)

        # Step Find_Contours0:

        self.__find_contours_input = self.blur_output
        self.find_contours_output = \
            self.__find_contours(self.__find_contours_input,
                                 self.__find_contours_external_only)

        # Step Filter_Contours0:

        self.__filter_contours_contours = self.find_contours_output
        return self.__filter_contours(
            self.__filter_contours_contours,
            self.__filter_contours_min_area,
            self.__filter_contours_min_perimeter,
            self.__filter_contours_min_width,
            self.__filter_contours_max_width,
            self.__filter_contours_min_height,
            self.__filter_contours_max_height,
            self.__filter_contours_solidity,
            self.__filter_contours_max_vertices,
            self.__filter_contours_min_vertices,
            self.__filter_contours_min_ratio,
            self.__filter_contours_max_ratio,
            )

    @staticmethod
    def __hsl_threshold(
        input,
        hue,
        sat,
        lum,
        ):
        """Segment an image based on hue, saturation, and luminance ranges.
........Args:
............input: A BGR numpy.ndarray.
............hue: A list of two numbers the are the min and max hue.
............sat: A list of two numbers the are the min and max saturation.
............lum: A list of two numbers the are the min and max luminance.
........Returns:
............A black and white numpy.ndarray.
........"""

        out = cv2.cvtColor(input, cv2.COLOR_BGR2HLS)
        return cv2.inRange(out, (hue[0], lum[0], sat[0]), (hue[1],
                           lum[1], sat[1]))

    @staticmethod
    def __blur(src, type, radius):
        """Softens an image using one of several filters.
........Args:
........src: The source mat (numpy.ndarray).
........type: The blurType to perform represented as an int.
........radius: The radius for the blur as a float.
........Returns:
........A numpy.ndarray that has been blurred.
........"""

        if type is BlurType.Box_Blur:
            ksize = int(2 * round(radius) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif type is BlurType.Gaussian_Blur:
            ksize = int(6 * round(radius) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(radius))
        elif type is BlurType.Median_Filter:
            ksize = int(2 * round(radius) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(radius),
                    round(radius))

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
........Args:
............input: A numpy.ndarray.
............external_only: A boolean. If true only external contours are found.
........Return:
............A list of numpy.ndarray where each one represents a contour.
........"""

        if external_only:
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        (im2, contours, hierarchy) = cv2.findContours(input, mode=mode,
                method=method)
        return contours

    @staticmethod
    def __filter_contours(
        input_contours,
        min_area,
        min_perimeter,
        min_width,
        max_width,
        min_height,
        max_height,
        solidity,
        max_vertex_count,
        min_vertex_count,
        min_ratio,
        max_ratio,
        ):
        """Filters out contours that do not meet certain criteria.
........Args:
............input_contours: Contours as a list of numpy.ndarray.
............min_area: The minimum area of a contour that will be kept.
............min_perimeter: The minimum perimeter of a contour that will be kept.
............min_width: Minimum width of a contour.
............max_width: MaxWidth maximum width.
............min_height: Minimum height.
............max_height: Maximum height.
............solidity: The minimum and maximum solidity of a contour.
............min_vertex_count: Minimum vertex Count of the contours.
............max_vertex_count: Maximum vertex Count.
............min_ratio: Minimum ratio of width to height.
............max_ratio: Maximum ratio of width to height.
........Returns:
............Contours as a list of numpy.ndarray.
........"""

        output = []
        for contour in input_contours:
            (x, y, w, h) = cv2.boundingRect(contour)
            if w < min_width or w > max_width:
                continue
            if h < min_height or h > max_height:
                continue
            area = cv2.contourArea(contour)
            if area < min_area:
                continue
            if cv2.arcLength(contour, True) < min_perimeter:
                continue
            hull = cv2.convexHull(contour)
            solid = 100 * area / cv2.contourArea(hull)
            if solid < solidity[0] or solid > solidity[1]:
                continue
            if len(contour) < min_vertex_count or len(contour) \
                > max_vertex_count:
                continue
            ratio = float(w) / h
            if ratio < min_ratio or ratio > max_ratio:
                continue
            output.append(contour)
        return output

    def getCoords(self):
        return self.name


class Sender:
    """
    Class responsible for all data sent from Raspberry Pi to both NT server and DS server
    """

    FRAMERATE_PERIOD = 1 / 15

    def __init__(serverIP, serverPort, networktableIP):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.mode_gear = True

        sock.connect((serverIP, serverPort))
        NetworkTables.initialize(server=networktableIP)

        self.gear = NetworkTables.getTable('cameraData/gear')
        self.shooter = NetworkTables.getTable('cameraData/shooter')
        self.camera_data = NetworkTables.getTable('cameraData')

    def update_camera_feed(self, retriever):
        global isOn
        while isOn:   
            self.mode_gear = camera_data.getBoolean('gearMode',
                    defaultValue=True)
            if self.mode_gear:
                frame = retriever.get_latest_gear()
            else:
                frame = retriever.get_latest_shooter()
            im = cv2.imencode('.jpg', frame)[1].tostring()
            self.sock.send(im)
            time.sleep(FRAMERATE_PERIOD)

    def update_gear_coords(self, pointOne, pointTwo):
        self.gear.putNumber('pointOneX', pointOne[0])
        self.gear.putNumber('pointOneY', pointOne[1])
        self.gear.putNumber('pointTwoX', pointTwo[0])
        self.gear.putNumber('pointTwoY', pointTwo[1])

    def update_shooter_coords(self, pointOne, pointTwo):
        self.shooter.putNumber('pointOneX', pointOne[0])
        self.shooter.putNumber('pointOneY', pointOne[1])
        self.shooter.putNumber('pointTwoX', pointTwo[0])
        self.shooter.putNumber('pointTwoY', pointTwo[1])


class ImageRetriever:

    def __init__():
        self.gearCam = cv2.VideoCapture(0)
        self.gearCam.set(cv2.CAP_PROP_FRAME_WIDTH, 360)
        self.gearCam.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)
        self.gearCam.set(cv2.CAP_PROP_FPS, 15)

        self.shooterCam = cv2.VideoCapture(1)
        self.shooterCam.set(cv2.CAP_PROP_FRAME_WIDTH, 360)
        self.shooterCam.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)
        self.shooterCam.set(cv2.CAP_PROP_FPS, 15)

    def get_latest_gear():
        return self.gearCam.read()[1]

    def get_latest_shooter():
        return self.shooterCam.read()[1]


if __name__ == '__main__':
    global isOn
    isOn = True
    executive = Main()
    executive.start()

            
